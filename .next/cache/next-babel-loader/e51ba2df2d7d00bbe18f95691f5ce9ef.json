{"ast":null,"code":"import { GEN_ONE_POKEMON, emojiFor } from \"../pokemon\";\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (event, client, prisma) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`\n      });\n      return;\n    }\n\n    usersFromMessage(event.text, client).then(async rawOpponents => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n      const opponents = rawOpponents.filter(o => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(prisma, event.team, opponent.id);\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`\n        });\n        return;\n      }\n\n      const rsp = await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(usersPokemon)}: ${usersPokemon.name.english} against <@${opponent.id}>'s :${emojiFor(opponentsPokemon)}: ${opponentsPokemon.name.english}`\n      });\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`\n      });\n    });\n  }\n};\n\nconst usersFromMessage = (text, client) => {\n  return Promise.all(Array.from(text.matchAll(/<@(\\w+)>/g)).map(async m => {\n    console.log(\"Fetching \", m[1]);\n    const response = await client.users.info({\n      user: m[1]\n    });\n    return response.user;\n  }));\n};\n\nconst currentPokemonForUser = async (prisma, teamId, userId) => {\n  const r = await prisma.roll.findMany({\n    where: {\n      teamId,\n      userId\n    },\n    orderBy: {\n      createdAt: \"desc\"\n    },\n    take: 1\n  });\n\n  if (r.length === 0) {\n    return null;\n  }\n\n  return GEN_ONE_POKEMON[r[0].pokemonNumber - 1];\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/lib/responders/battle.ts"],"names":["GEN_ONE_POKEMON","emojiFor","id","triggerPhrase","respond","event","client","prisma","usersPokemon","pokeForUser","team","user","chat","postMessage","channel","text","usersFromMessage","then","rawOpponents","console","log","JSON","stringify","opponents","filter","o","is_bot","length","opponent","opponentsPokemon","rsp","name","english","thread_ts","ts","Promise","all","Array","from","matchAll","map","m","response","users","info","currentPokemonForUser","teamId","userId","r","roll","findMany","where","orderBy","createdAt","take","pokemonNumber"],"mappings":"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","sourcesContent":["import { WebClient, WebAPICallResult } from \"@slack/web-api\";\nimport { PrismaClient, Roll } from \"@prisma/client\";\n\nimport { MentionEvent } from \"../slack\";\nimport { Responder } from \"./\";\nimport { Pokemon, GEN_ONE_POKEMON, emojiFor } from \"../pokemon\";\n\ntype SlackUser = {\n  id: string;\n  is_bot: boolean;\n};\n\ntype PostMessageResult = WebAPICallResult & {\n  ts: string;\n};\n\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (\n    event: MentionEvent,\n    client: WebClient,\n    prisma: PrismaClient\n  ) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`,\n      });\n      return;\n    }\n\n    usersFromMessage(event.text, client).then(async (rawOpponents) => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n\n      const opponents = rawOpponents.filter((o) => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`,\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`,\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(\n        prisma,\n        event.team,\n        opponent.id\n      );\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`,\n        });\n        return;\n      }\n\n      const rsp = (await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(\n          usersPokemon\n        )}: ${usersPokemon.name.english} against <@${\n          opponent.id\n        }>'s :${emojiFor(opponentsPokemon)}: ${opponentsPokemon.name.english}`,\n      })) as PostMessageResult;\n\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`,\n      });\n    });\n  },\n} as Responder;\n\nconst usersFromMessage = (\n  text: string,\n  client: WebClient\n): Promise<SlackUser[]> => {\n  return Promise.all(\n    Array.from(text.matchAll(/<@(\\w+)>/g)).map(async (m) => {\n      console.log(\"Fetching \", m[1]);\n      const response = await client.users.info({ user: m[1] });\n      return response.user as SlackUser;\n    })\n  );\n};\n\nconst currentPokemonForUser = async (\n  prisma: PrismaClient,\n  teamId: string,\n  userId: string\n): Promise<Pokemon | null> => {\n  const r = await prisma.roll.findMany({\n    where: { teamId, userId },\n    orderBy: { createdAt: \"desc\" },\n    take: 1,\n  });\n\n  if (r.length === 0) {\n    return null;\n  }\n\n  return GEN_ONE_POKEMON[r[0].pokemonNumber - 1];\n};\n"]},"metadata":{},"sourceType":"module"}