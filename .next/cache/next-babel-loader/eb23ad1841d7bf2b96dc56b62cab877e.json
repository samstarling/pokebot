{"ast":null,"code":"import { currentPokemonForUser, emojiFor } from \"../pokemon\";\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (event, client, prisma) => {\n    const usersPokemon = await currentPokemonForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`\n      });\n      return;\n    }\n\n    usersFromMessage(event.text, client).then(async rawOpponents => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n      const opponents = rawOpponents.filter(o => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await currentPokemonForUser(prisma, event.team, opponent.id);\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`\n        });\n        return;\n      }\n\n      const rsp = await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(usersPokemon)}: ${usersPokemon.name} against <@${opponent.id}>'s :${emojiFor(opponentsPokemon)}: ${opponentsPokemon.name}`\n      });\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`\n      });\n    });\n  }\n};\n\nconst usersFromMessage = (text, client) => {\n  return Promise.all(Array.from(text.matchAll(/<@(\\w+)>/g)).map(async m => {\n    console.log(\"Fetching \", m[1]);\n    const response = await client.users.info({\n      user: m[1]\n    });\n    return response.user;\n  }));\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/lib/responders/battle.ts"],"names":["currentPokemonForUser","emojiFor","id","triggerPhrase","respond","event","client","prisma","usersPokemon","team","user","chat","postMessage","channel","text","usersFromMessage","then","rawOpponents","console","log","JSON","stringify","opponents","filter","o","is_bot","length","opponent","opponentsPokemon","rsp","name","thread_ts","ts","Promise","all","Array","from","matchAll","map","m","response","users","info"],"mappings":"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","sourcesContent":["import { WebClient, WebAPICallResult } from \"@slack/web-api\";\nimport { PrismaClient } from \"@prisma/client\";\n\nimport { MentionEvent } from \"../slack\";\nimport { Responder } from \"./\";\nimport { currentPokemonForUser, emojiFor } from \"../pokemon\";\n\ntype SlackUser = {\n  id: string;\n  is_bot: boolean;\n};\n\ntype PostMessageResult = WebAPICallResult & {\n  ts: string;\n};\n\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (\n    event: MentionEvent,\n    client: WebClient,\n    prisma: PrismaClient\n  ) => {\n    const usersPokemon = await currentPokemonForUser(\n      prisma,\n      event.team,\n      event.user\n    );\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`,\n      });\n      return;\n    }\n\n    usersFromMessage(event.text, client).then(async (rawOpponents) => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n\n      const opponents = rawOpponents.filter((o) => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`,\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`,\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await currentPokemonForUser(\n        prisma,\n        event.team,\n        opponent.id\n      );\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`,\n        });\n        return;\n      }\n\n      const rsp = (await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(\n          usersPokemon\n        )}: ${usersPokemon.name} against <@${opponent.id}>'s :${emojiFor(\n          opponentsPokemon\n        )}: ${opponentsPokemon.name}`,\n      })) as PostMessageResult;\n\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`,\n      });\n    });\n  },\n} as Responder;\n\nconst usersFromMessage = (\n  text: string,\n  client: WebClient\n): Promise<SlackUser[]> => {\n  return Promise.all(\n    Array.from(text.matchAll(/<@(\\w+)>/g)).map(async (m) => {\n      console.log(\"Fetching \", m[1]);\n      const response = await client.users.info({ user: m[1] });\n      return response.user as SlackUser;\n    })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}