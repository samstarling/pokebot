{"ast":null,"code":"import { POKEMON, emojiFor } from \"../pokemon\";\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (event, client, prisma) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`\n      });\n      return;\n    }\n\n    const currentPokemon = POKEMON[usersPokemon.pokemonNumber - 1];\n    console.log(\"Event text\", event.text);\n    Promise.all(Array.from(event.text.matchAll(/<@(\\w+)>/g)).map(async m => {\n      console.log(\"Fetching \", m[1]);\n      const response = await client.users.info({\n        user: m[1]\n      });\n      return response.user;\n    })).then(async rawOpponents => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n      const opponents = rawOpponents.filter(o => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(prisma, event.team, opponent.id);\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon = POKEMON[opponentsPokemon.pokemonNumber - 1];\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(currentPokemon)}: ${currentPokemon.name.english} against <@${opponent.id}>'s :${emojiFor(opponentsCurrentPokemon)}: ${opponentsCurrentPokemon.name.english}`\n      });\n    });\n  }\n};\n\nconst pokeForUser = async (prisma, teamId, userId) => {\n  const r = await prisma.roll.findMany({\n    where: {\n      teamId,\n      userId\n    },\n    orderBy: {\n      createdAt: \"desc\"\n    },\n    take: 1\n  });\n  return r[0];\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/lib/responders/battle.ts"],"names":["POKEMON","emojiFor","id","triggerPhrase","respond","event","client","prisma","usersPokemon","pokeForUser","team","user","chat","postMessage","channel","text","currentPokemon","pokemonNumber","console","log","Promise","all","Array","from","matchAll","map","m","response","users","info","then","rawOpponents","JSON","stringify","opponents","filter","o","is_bot","length","opponent","opponentsPokemon","opponentsCurrentPokemon","name","english","teamId","userId","r","roll","findMany","where","orderBy","createdAt","take"],"mappings":"AAKA,SAASA,OAAT,EAAkBC,QAAlB,QAAkC,YAAlC;AAOA,eAAe;AACbC,EAAAA,EAAE,EAAE,QADS;AAEbC,EAAAA,aAAa,EAAE,QAFF;AAGbC,EAAAA,OAAO,EAAE,OACPC,KADO,EAEPC,MAFO,EAGPC,MAHO,KAIJ;AACH,UAAMC,YAAY,GAAG,MAAMC,WAAW,CAACF,MAAD,EAASF,KAAK,CAACK,IAAf,EAAqBL,KAAK,CAACM,IAA3B,CAAtC;;AAEA,QAAI,CAACH,YAAL,EAAmB;AACjB,YAAMF,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,QAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,QAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,OAAxB,CAAN;AAIA;AACD;;AAED,UAAMK,cAAc,GAAGhB,OAAO,CAACQ,YAAY,CAACS,aAAb,GAA6B,CAA9B,CAA9B;AAEAC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0Bd,KAAK,CAACU,IAAhC;AAEAK,IAAAA,OAAO,CAACC,GAAR,CACEC,KAAK,CAACC,IAAN,CAAWlB,KAAK,CAACU,IAAN,CAAWS,QAAX,CAAoB,WAApB,CAAX,EAA6CC,GAA7C,CAAiD,MAAOC,CAAP,IAAa;AAC5DR,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBO,CAAC,CAAC,CAAD,CAA1B;AACA,YAAMC,QAAQ,GAAG,MAAMrB,MAAM,CAACsB,KAAP,CAAaC,IAAb,CAAkB;AAAElB,QAAAA,IAAI,EAAEe,CAAC,CAAC,CAAD;AAAT,OAAlB,CAAvB;AACA,aAAOC,QAAQ,CAAChB,IAAhB;AACD,KAJD,CADF,EAMEmB,IANF,CAMO,MAAOC,YAAP,IAAwB;AAC7Bb,MAAAA,OAAO,CAACC,GAAR,CAAYa,IAAI,CAACC,SAAL,CAAeF,YAAf,EAA6B,IAA7B,EAAmC,CAAnC,CAAZ;AAEA,YAAMG,SAAS,GAAGH,YAAY,CAACI,MAAb,CAAqBC,CAAD,IAAO,CAACA,CAAC,CAACC,MAA9B,CAAlB;;AAEA,UAAIH,SAAS,CAACI,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,cAAMhC,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,SAAxB,CAAN;AAID;;AAED,UAAIuB,SAAS,CAACI,MAAV,GAAmB,CAAvB,EAA0B;AACxB,cAAMhC,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,SAAxB,CAAN;AAID;;AAED,YAAM4B,QAAQ,GAAGL,SAAS,CAAC,CAAD,CAA1B;AACA,YAAMM,gBAAgB,GAAG,MAAM/B,WAAW,CACxCF,MADwC,EAExCF,KAAK,CAACK,IAFkC,EAGxC6B,QAAQ,CAACrC,EAH+B,CAA1C;;AAMA,UAAI,CAACsC,gBAAL,EAAuB;AACrB,cAAMlC,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK,cAAa4B,QAAQ,CAACrC,EAAG;AAFnB,SAAxB,CAAN;AAIA;AACD;;AAED,YAAMuC,uBAAuB,GAC3BzC,OAAO,CAACwC,gBAAgB,CAACvB,aAAjB,GAAiC,CAAlC,CADT;AAGA,YAAMX,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,QAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,QAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK,yBAAwBV,QAAQ,CACpDe,cADoD,CAEpD,KAAIA,cAAc,CAAC0B,IAAf,CAAoBC,OAAQ,cAChCJ,QAAQ,CAACrC,EACV,QAAOD,QAAQ,CAACwC,uBAAD,CAA0B,KACxCA,uBAAuB,CAACC,IAAxB,CAA6BC,OAC9B;AAR2B,OAAxB,CAAN;AAUD,KArDD;AAsDD;AA5EY,CAAf;;AA+EA,MAAMlC,WAAW,GAAG,OAClBF,MADkB,EAElBqC,MAFkB,EAGlBC,MAHkB,KAIA;AAClB,QAAMC,CAAC,GAAG,MAAMvC,MAAM,CAACwC,IAAP,CAAYC,QAAZ,CAAqB;AACnCC,IAAAA,KAAK,EAAE;AAAEL,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAD4B;AAEnCK,IAAAA,OAAO,EAAE;AAAEC,MAAAA,SAAS,EAAE;AAAb,KAF0B;AAGnCC,IAAAA,IAAI,EAAE;AAH6B,GAArB,CAAhB;AAKA,SAAON,CAAC,CAAC,CAAD,CAAR;AACD,CAXD","sourcesContent":["import { WebClient } from \"@slack/web-api\";\nimport { PrismaClient, Roll } from \"@prisma/client\";\n\nimport { MentionEvent } from \"../slack\";\nimport { Responder } from \"./\";\nimport { POKEMON, emojiFor } from \"../pokemon\";\n\ntype SlackUser = {\n  id: string;\n  is_bot: boolean;\n};\n\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (\n    event: MentionEvent,\n    client: WebClient,\n    prisma: PrismaClient\n  ) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`,\n      });\n      return;\n    }\n\n    const currentPokemon = POKEMON[usersPokemon.pokemonNumber - 1];\n\n    console.log(\"Event text\", event.text);\n\n    Promise.all(\n      Array.from(event.text.matchAll(/<@(\\w+)>/g)).map(async (m) => {\n        console.log(\"Fetching \", m[1]);\n        const response = await client.users.info({ user: m[1] });\n        return response.user as SlackUser;\n      })\n    ).then(async (rawOpponents) => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n\n      const opponents = rawOpponents.filter((o) => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`,\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`,\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(\n        prisma,\n        event.team,\n        opponent.id\n      );\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`,\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon =\n        POKEMON[opponentsPokemon.pokemonNumber - 1];\n\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(\n          currentPokemon\n        )}: ${currentPokemon.name.english} against <@${\n          opponent.id\n        }>'s :${emojiFor(opponentsCurrentPokemon)}: ${\n          opponentsCurrentPokemon.name.english\n        }`,\n      });\n    });\n  },\n} as Responder;\n\nconst pokeForUser = async (\n  prisma: PrismaClient,\n  teamId: string,\n  userId: string\n): Promise<Roll> => {\n  const r = await prisma.roll.findMany({\n    where: { teamId, userId },\n    orderBy: { createdAt: \"desc\" },\n    take: 1,\n  });\n  return r[0];\n};\n"]},"metadata":{},"sourceType":"module"}