{"ast":null,"code":"import { POKEMON, emojiFor } from \"../pokemon\";\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (event, client, prisma) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`\n      });\n      return;\n    }\n\n    const currentPokemon = POKEMON[usersPokemon.pokemonNumber - 1];\n    Promise.all(Array.from(event.text.matchAll(/<@(\\w+)>/)).map(async m => {\n      const response = await client.users.info({\n        user: m[1]\n      });\n      return response.user;\n    })).then(async rawOpponents => {\n      const opponents = rawOpponents.filter(o => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(prisma, event.team, opponent.id);\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon = POKEMON[opponentsPokemon.pokemonNumber - 1];\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(currentPokemon)}: ${currentPokemon.name.english} against <@${opponent.id}>'s :${emojiFor(opponentsCurrentPokemon)} ${opponentsCurrentPokemon.name.english}`\n      });\n    });\n  }\n};\n\nconst pokeForUser = async (prisma, teamId, userId) => {\n  const r = await prisma.roll.findMany({\n    where: {\n      teamId,\n      userId\n    },\n    orderBy: {\n      createdAt: \"desc\"\n    },\n    take: 1\n  });\n  return r[0];\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/lib/responders/battle.ts"],"names":["POKEMON","emojiFor","id","triggerPhrase","respond","event","client","prisma","usersPokemon","pokeForUser","team","user","chat","postMessage","channel","text","currentPokemon","pokemonNumber","Promise","all","Array","from","matchAll","map","m","response","users","info","then","rawOpponents","opponents","filter","o","is_bot","length","opponent","opponentsPokemon","opponentsCurrentPokemon","name","english","teamId","userId","r","roll","findMany","where","orderBy","createdAt","take"],"mappings":"AAKA,SAASA,OAAT,EAA2BC,QAA3B,QAA2C,YAA3C;AAOA,eAAe;AACbC,EAAAA,EAAE,EAAE,QADS;AAEbC,EAAAA,aAAa,EAAE,QAFF;AAGbC,EAAAA,OAAO,EAAE,OACPC,KADO,EAEPC,MAFO,EAGPC,MAHO,KAIJ;AACH,UAAMC,YAAY,GAAG,MAAMC,WAAW,CAACF,MAAD,EAASF,KAAK,CAACK,IAAf,EAAqBL,KAAK,CAACM,IAA3B,CAAtC;;AAEA,QAAI,CAACH,YAAL,EAAmB;AACjB,YAAMF,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,QAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,QAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,OAAxB,CAAN;AAIA;AACD;;AAED,UAAMK,cAAc,GAAGhB,OAAO,CAACQ,YAAY,CAACS,aAAb,GAA6B,CAA9B,CAA9B;AAEAC,IAAAA,OAAO,CAACC,GAAR,CACEC,KAAK,CAACC,IAAN,CAAWhB,KAAK,CAACU,IAAN,CAAWO,QAAX,CAAoB,UAApB,CAAX,EAA4CC,GAA5C,CAAgD,MAAOC,CAAP,IAAa;AAC3D,YAAMC,QAAQ,GAAG,MAAMnB,MAAM,CAACoB,KAAP,CAAaC,IAAb,CAAkB;AAAEhB,QAAAA,IAAI,EAAEa,CAAC,CAAC,CAAD;AAAT,OAAlB,CAAvB;AACA,aAAOC,QAAQ,CAACd,IAAhB;AACD,KAHD,CADF,EAKEiB,IALF,CAKO,MAAOC,YAAP,IAAwB;AAC7B,YAAMC,SAAS,GAAGD,YAAY,CAACE,MAAb,CAAqBC,CAAD,IAAO,CAACA,CAAC,CAACC,MAA9B,CAAlB;;AAEA,UAAIH,SAAS,CAACI,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,cAAM5B,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,SAAxB,CAAN;AAID;;AAED,UAAImB,SAAS,CAACI,MAAV,GAAmB,CAAvB,EAA0B;AACxB,cAAM5B,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK;AAFM,SAAxB,CAAN;AAID;;AAED,YAAMwB,QAAQ,GAAGL,SAAS,CAAC,CAAD,CAA1B;AACA,YAAMM,gBAAgB,GAAG,MAAM3B,WAAW,CACxCF,MADwC,EAExCF,KAAK,CAACK,IAFkC,EAGxCyB,QAAQ,CAACjC,EAH+B,CAA1C;;AAMA,UAAI,CAACkC,gBAAL,EAAuB;AACrB,cAAM9B,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,UAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,UAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK,cAAawB,QAAQ,CAACjC,EAAG;AAFnB,SAAxB,CAAN;AAIA;AACD;;AAED,YAAMmC,uBAAuB,GAC3BrC,OAAO,CAACoC,gBAAgB,CAACnB,aAAjB,GAAiC,CAAlC,CADT;AAGA,YAAMX,MAAM,CAACM,IAAP,CAAYC,WAAZ,CAAwB;AAC5BC,QAAAA,OAAO,EAAET,KAAK,CAACS,OADa;AAE5BC,QAAAA,IAAI,EAAG,KAAIV,KAAK,CAACM,IAAK,yBAAwBV,QAAQ,CACpDe,cADoD,CAEpD,KAAIA,cAAc,CAACsB,IAAf,CAAoBC,OAAQ,cAChCJ,QAAQ,CAACjC,EACV,QAAOD,QAAQ,CAACoC,uBAAD,CAA0B,IACxCA,uBAAuB,CAACC,IAAxB,CAA6BC,OAC9B;AAR2B,OAAxB,CAAN;AAUD,KAlDD;AAmDD;AAvEY,CAAf;;AA0EA,MAAM9B,WAAW,GAAG,OAClBF,MADkB,EAElBiC,MAFkB,EAGlBC,MAHkB,KAIA;AAClB,QAAMC,CAAC,GAAG,MAAMnC,MAAM,CAACoC,IAAP,CAAYC,QAAZ,CAAqB;AACnCC,IAAAA,KAAK,EAAE;AAAEL,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAD4B;AAEnCK,IAAAA,OAAO,EAAE;AAAEC,MAAAA,SAAS,EAAE;AAAb,KAF0B;AAGnCC,IAAAA,IAAI,EAAE;AAH6B,GAArB,CAAhB;AAKA,SAAON,CAAC,CAAC,CAAD,CAAR;AACD,CAXD","sourcesContent":["import { WebClient } from \"@slack/web-api\";\nimport { PrismaClient, Roll } from \"@prisma/client\";\n\nimport { MentionEvent } from \"../slack\";\nimport { Responder } from \"./\";\nimport { POKEMON, pickOne, emojiFor } from \"../pokemon\";\n\ntype SlackUser = {\n  id: string;\n  is_bot: boolean;\n};\n\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (\n    event: MentionEvent,\n    client: WebClient,\n    prisma: PrismaClient\n  ) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`,\n      });\n      return;\n    }\n\n    const currentPokemon = POKEMON[usersPokemon.pokemonNumber - 1];\n\n    Promise.all(\n      Array.from(event.text.matchAll(/<@(\\w+)>/)).map(async (m) => {\n        const response = await client.users.info({ user: m[1] });\n        return response.user as SlackUser;\n      })\n    ).then(async (rawOpponents) => {\n      const opponents = rawOpponents.filter((o) => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`,\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`,\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(\n        prisma,\n        event.team,\n        opponent.id\n      );\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`,\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon =\n        POKEMON[opponentsPokemon.pokemonNumber - 1];\n\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(\n          currentPokemon\n        )}: ${currentPokemon.name.english} against <@${\n          opponent.id\n        }>'s :${emojiFor(opponentsCurrentPokemon)} ${\n          opponentsCurrentPokemon.name.english\n        }`,\n      });\n    });\n  },\n} as Responder;\n\nconst pokeForUser = async (\n  prisma: PrismaClient,\n  teamId: string,\n  userId: string\n): Promise<Roll> => {\n  const r = await prisma.roll.findMany({\n    where: { teamId, userId },\n    orderBy: { createdAt: \"desc\" },\n    take: 1,\n  });\n  return r[0];\n};\n"]},"metadata":{},"sourceType":"module"}