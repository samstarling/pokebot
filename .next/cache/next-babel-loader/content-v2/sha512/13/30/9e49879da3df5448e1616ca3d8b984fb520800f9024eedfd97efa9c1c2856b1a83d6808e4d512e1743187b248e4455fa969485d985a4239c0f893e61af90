{"ast":null,"code":"import \"reflect-metadata\";\nimport { createEventAdapter } from \"@slack/events-api\";\nimport { WebClient } from \"@slack/web-api\";\nimport { installer } from \"../../lib/slack/installer\";\nimport { RESPONDERS } from \"../../lib/responders\";\nimport { createConnection } from \"typeorm\";\nimport { Pokemon, Roll } from \"../../src/entity\";\nconst slackEvents = createEventAdapter(process.env.SLACK_SIGNING_SECRET || \"\");\ncreateConnection({\n  type: \"postgres\",\n  url: process.env.DATABASE_URL,\n  entities: [Pokemon, Roll],\n  schema: \"public\",\n  synchronize: false,\n  logging: true\n}).then(async connection => {\n  const pokeRepo = connection.getRepository(Pokemon);\n  const rollRepo = connection.getRepository(Roll);\n  slackEvents.on(\"app_mention\", async event => {\n    const installData = await installer.authorize({\n      teamId: event.team,\n      isEnterpriseInstall: false,\n      enterpriseId: event.enterprise_id\n    });\n    const client = new WebClient(installData.botToken);\n    RESPONDERS.forEach(async r => {\n      const sanitizedText = event.text.toLowerCase().replace(\"’\", \"'\");\n\n      if (sanitizedText.includes(r.triggerPhrase.toLowerCase())) {\n        r.respond({\n          event,\n          client,\n          pokeRepo,\n          rollRepo\n        });\n      }\n    });\n  });\n}).catch(error => console.log(error));\nexport default slackEvents.requestListener();\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true\n  }\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/pages/api/event.ts"],"names":["createEventAdapter","WebClient","installer","RESPONDERS","createConnection","Pokemon","Roll","slackEvents","process","env","SLACK_SIGNING_SECRET","type","url","DATABASE_URL","entities","schema","synchronize","logging","then","connection","pokeRepo","getRepository","rollRepo","on","event","installData","authorize","teamId","team","isEnterpriseInstall","enterpriseId","enterprise_id","client","botToken","forEach","r","sanitizedText","text","toLowerCase","replace","includes","triggerPhrase","respond","catch","error","console","log","requestListener","config","api","bodyParser","externalResolver"],"mappings":"AAAA,OAAO,kBAAP;AAEA,SAASA,kBAAT,QAAmC,mBAAnC;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAEA,SAASC,SAAT,QAA0B,2BAA1B;AAEA,SAASC,UAAT,QAA2B,sBAA3B;AAEA,SAASC,gBAAT,QAAiC,SAAjC;AACA,SAASC,OAAT,EAAkBC,IAAlB,QAA8B,kBAA9B;AAEA,MAAMC,WAAW,GAAGP,kBAAkB,CAACQ,OAAO,CAACC,GAAR,CAAYC,oBAAZ,IAAoC,EAArC,CAAtC;AAEAN,gBAAgB,CAAC;AACfO,EAAAA,IAAI,EAAE,UADS;AAEfC,EAAAA,GAAG,EAAEJ,OAAO,CAACC,GAAR,CAAYI,YAFF;AAGfC,EAAAA,QAAQ,EAAE,CAACT,OAAD,EAAUC,IAAV,CAHK;AAIfS,EAAAA,MAAM,EAAE,QAJO;AAKfC,EAAAA,WAAW,EAAE,KALE;AAMfC,EAAAA,OAAO,EAAE;AANM,CAAD,CAAhB,CAQGC,IARH,CAQQ,MAAOC,UAAP,IAAsB;AAC1B,QAAMC,QAAQ,GAAGD,UAAU,CAACE,aAAX,CAAyBhB,OAAzB,CAAjB;AACA,QAAMiB,QAAQ,GAAGH,UAAU,CAACE,aAAX,CAAyBf,IAAzB,CAAjB;AAEAC,EAAAA,WAAW,CAACgB,EAAZ,CAAe,aAAf,EAA8B,MAAOC,KAAP,IAA+B;AAC3D,UAAMC,WAAW,GAAG,MAAMvB,SAAS,CAACwB,SAAV,CAAoB;AAC5CC,MAAAA,MAAM,EAAEH,KAAK,CAACI,IAD8B;AAE5CC,MAAAA,mBAAmB,EAAE,KAFuB;AAG5CC,MAAAA,YAAY,EAAEN,KAAK,CAACO;AAHwB,KAApB,CAA1B;AAKA,UAAMC,MAAM,GAAG,IAAI/B,SAAJ,CAAcwB,WAAW,CAACQ,QAA1B,CAAf;AAEA9B,IAAAA,UAAU,CAAC+B,OAAX,CAAmB,MAAOC,CAAP,IAAa;AAC9B,YAAMC,aAAa,GAAGZ,KAAK,CAACa,IAAN,CAAWC,WAAX,GAAyBC,OAAzB,CAAiC,GAAjC,EAAsC,GAAtC,CAAtB;;AACA,UAAIH,aAAa,CAACI,QAAd,CAAuBL,CAAC,CAACM,aAAF,CAAgBH,WAAhB,EAAvB,CAAJ,EAA2D;AACzDH,QAAAA,CAAC,CAACO,OAAF,CAAU;AAAElB,UAAAA,KAAF;AAASQ,UAAAA,MAAT;AAAiBZ,UAAAA,QAAjB;AAA2BE,UAAAA;AAA3B,SAAV;AACD;AACF,KALD;AAMD,GAdD;AAeD,CA3BH,EA4BGqB,KA5BH,CA4BUC,KAAD,IAAWC,OAAO,CAACC,GAAR,CAAYF,KAAZ,CA5BpB;AA8BA,eAAerC,WAAW,CAACwC,eAAZ,EAAf;AAEA,OAAO,MAAMC,MAAM,GAAG;AACpBC,EAAAA,GAAG,EAAE;AACHC,IAAAA,UAAU,EAAE,KADT;AAEHC,IAAAA,gBAAgB,EAAE;AAFf;AADe,CAAf","sourcesContent":["import \"reflect-metadata\";\n\nimport { createEventAdapter } from \"@slack/events-api\";\nimport { WebClient } from \"@slack/web-api\";\n\nimport { installer } from \"../../lib/slack/installer\";\nimport { MentionEvent } from \"../../lib/slack\";\nimport { RESPONDERS } from \"../../lib/responders\";\n\nimport { createConnection } from \"typeorm\";\nimport { Pokemon, Roll } from \"../../src/entity\";\n\nconst slackEvents = createEventAdapter(process.env.SLACK_SIGNING_SECRET || \"\");\n\ncreateConnection({\n  type: \"postgres\",\n  url: process.env.DATABASE_URL,\n  entities: [Pokemon, Roll],\n  schema: \"public\",\n  synchronize: false,\n  logging: true,\n})\n  .then(async (connection) => {\n    const pokeRepo = connection.getRepository(Pokemon);\n    const rollRepo = connection.getRepository(Roll);\n\n    slackEvents.on(\"app_mention\", async (event: MentionEvent) => {\n      const installData = await installer.authorize({\n        teamId: event.team,\n        isEnterpriseInstall: false,\n        enterpriseId: event.enterprise_id,\n      });\n      const client = new WebClient(installData.botToken);\n\n      RESPONDERS.forEach(async (r) => {\n        const sanitizedText = event.text.toLowerCase().replace(\"’\", \"'\");\n        if (sanitizedText.includes(r.triggerPhrase.toLowerCase())) {\n          r.respond({ event, client, pokeRepo, rollRepo });\n        }\n      });\n    });\n  })\n  .catch((error) => console.log(error));\n\nexport default slackEvents.requestListener();\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};\n"]},"metadata":{},"sourceType":"module"}