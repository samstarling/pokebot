{"ast":null,"code":"import { GEN_ONE_POKEMON, emojiFor } from \"../pokemon\";\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (event, client, prisma) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`\n      });\n      return;\n    }\n\n    const currentPokemon = GEN_ONE_POKEMON[usersPokemon.pokemonNumber - 1];\n    usersFromMessage(event.text, client).then(async rawOpponents => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n      const opponents = rawOpponents.filter(o => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(prisma, event.team, opponent.id);\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon = GEN_ONE_POKEMON[opponentsPokemon.pokemonNumber - 1];\n      const rsp = await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(currentPokemon)}: ${currentPokemon.name.english} against <@${opponent.id}>'s :${emojiFor(opponentsCurrentPokemon)}: ${opponentsCurrentPokemon.name.english}`\n      });\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`\n      });\n    });\n  }\n};\n\nconst usersFromMessage = (text, client) => {\n  return Promise.all(Array.from(text.matchAll(/<@(\\w+)>/g)).map(async m => {\n    console.log(\"Fetching \", m[1]);\n    const response = await client.users.info({\n      user: m[1]\n    });\n    return response.user;\n  }));\n};\n\nconst pokeForUser = async (prisma, teamId, userId) => {\n  const r = await prisma.roll.findMany({\n    where: {\n      teamId,\n      userId\n    },\n    orderBy: {\n      createdAt: \"desc\"\n    },\n    take: 1\n  });\n\n  if (r.length === 0) {\n    return null;\n  }\n\n  return GEN_ONE_POKEMON[r[0].pokemonNumber - 1];\n};","map":{"version":3,"sources":["/Users/samstarling/Development/personal/pokebot/lib/responders/battle.ts"],"names":["GEN_ONE_POKEMON","emojiFor","id","triggerPhrase","respond","event","client","prisma","usersPokemon","pokeForUser","team","user","chat","postMessage","channel","text","currentPokemon","pokemonNumber","usersFromMessage","then","rawOpponents","console","log","JSON","stringify","opponents","filter","o","is_bot","length","opponent","opponentsPokemon","opponentsCurrentPokemon","rsp","name","english","thread_ts","ts","Promise","all","Array","from","matchAll","map","m","response","users","info","teamId","userId","r","roll","findMany","where","orderBy","createdAt","take"],"mappings":"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","sourcesContent":["import { WebClient, WebAPICallResult } from \"@slack/web-api\";\nimport { PrismaClient, Roll } from \"@prisma/client\";\n\nimport { MentionEvent } from \"../slack\";\nimport { Responder } from \"./\";\nimport { GEN_ONE_POKEMON, emojiFor } from \"../pokemon\";\n\ntype SlackUser = {\n  id: string;\n  is_bot: boolean;\n};\n\ntype PostMessageResult = WebAPICallResult & {\n  ts: string;\n};\n\nexport default {\n  id: \"battle\",\n  triggerPhrase: \"Battle\",\n  respond: async (\n    event: MentionEvent,\n    client: WebClient,\n    prisma: PrismaClient\n  ) => {\n    const usersPokemon = await pokeForUser(prisma, event.team, event.user);\n\n    if (!usersPokemon) {\n      await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}> You don't have a Pokémon!`,\n      });\n      return;\n    }\n\n    const currentPokemon = GEN_ONE_POKEMON[usersPokemon.pokemonNumber - 1];\n\n    usersFromMessage(event.text, client).then(async (rawOpponents) => {\n      console.log(JSON.stringify(rawOpponents, null, 2));\n\n      const opponents = rawOpponents.filter((o) => !o.is_bot);\n\n      if (opponents.length === 0) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You have to pick a human to battle!`,\n        });\n      }\n\n      if (opponents.length > 1) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> You can't battle more than one person`,\n        });\n      }\n\n      const opponent = opponents[0];\n      const opponentsPokemon = await pokeForUser(\n        prisma,\n        event.team,\n        opponent.id\n      );\n\n      if (!opponentsPokemon) {\n        await client.chat.postMessage({\n          channel: event.channel,\n          text: `<@${event.user}> Sorry, <@${opponent.id}> doesn't have a Pokémon!`,\n        });\n        return;\n      }\n\n      const opponentsCurrentPokemon =\n        GEN_ONE_POKEMON[opponentsPokemon.pokemonNumber - 1];\n\n      const rsp = (await client.chat.postMessage({\n        channel: event.channel,\n        text: `<@${event.user}>: Let's battle your :${emojiFor(\n          currentPokemon\n        )}: ${currentPokemon.name.english} against <@${\n          opponent.id\n        }>'s :${emojiFor(opponentsCurrentPokemon)}: ${\n          opponentsCurrentPokemon.name.english\n        }`,\n      })) as PostMessageResult;\n\n      await client.chat.postMessage({\n        channel: event.channel,\n        thread_ts: rsp.ts,\n        text: `You'll have to <https://pokemon-battle.herokuapp.com/|battle yourselves>, I'm not that clever yet.`,\n      });\n    });\n  },\n} as Responder;\n\nconst usersFromMessage = (\n  text: string,\n  client: WebClient\n): Promise<SlackUser[]> => {\n  return Promise.all(\n    Array.from(text.matchAll(/<@(\\w+)>/g)).map(async (m) => {\n      console.log(\"Fetching \", m[1]);\n      const response = await client.users.info({ user: m[1] });\n      return response.user as SlackUser;\n    })\n  );\n};\n\nconst pokeForUser = async (\n  prisma: PrismaClient,\n  teamId: string,\n  userId: string\n): Promise<Pokemon | null> => {\n  const r = await prisma.roll.findMany({\n    where: { teamId, userId },\n    orderBy: { createdAt: \"desc\" },\n    take: 1,\n  });\n\n  if (r.length === 0) {\n    return null;\n  }\n\n  return GEN_ONE_POKEMON[r[0].pokemonNumber - 1];\n};\n"]},"metadata":{},"sourceType":"module"}